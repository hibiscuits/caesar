@ffi("C")
extern unsafe fn printf(fmt: &byte, ...) -> int

@ffi("C")
extern fn testStruct(a: Test)

struct Test
    m: float
    b: float
    x: float64

union UnionTest
    i: int
    f: float64

struct StructWithUnions
    u: UnionTest
    union
        asdf: int
        qwer: byte

unsafe fn main()
    let mut u = UnionTest {}
    
    u.i = 123
    printf("as int: %d; as float: %f\n", u.i, u.f)
    
    u.f = 123.0
    printf("as int: %d; as float: %f\n", u.i, u.f)
    
    let x = { a: 5, b: 3 }
    
    let s: StructWithUnions = { u: { f: 5.0 }, asdf: 0x01020304 }
    rrr(s)#, x)
    
    
    testStruct({ m: 1.5, b: 3.0, x: 4.5 })


unsafe fn rrr(q: StructWithUnions)#, p: { a: int64, b: int })
    printf("%f; %d; %d\n", q.u.f, q.qwer, 0)#, p.a * p.b)






# struct Range
#     start: isize
#     end: isize

# struct RangeIter
#     rng: &Range
#     pos: isize = 0

# @iter
# fn newRangeIter(rng: &Range) -> RangeIter as retVal
#     where rng owns retVal.rng
#     { rng: &rng }

# @iterNext
# fn rangeIterNext(&mut iter) -> isize?
#     if iter^.pos < iter^.rng^.end
#         let i = iter^.pos
#         iter^.pos += 1
#         return i

# @iterDone
# fn rangeIterDone(&iter) -> bool
#     return iter^.pos >= iter^.rng^.end

# for i in 1..<10
#     printf("%d\n", i)

# let $temp0
# $temp0 = Range { start: 1, end: 10 }
# let mut $temp1 = newRangeIter(&$temp0)
# loop
#     if rangeIterDone(&$temp1)
#         break
#     else
#         let i
#         i = rangeIterNext(&$temp1)
#         printf("%d\n", i)




# struct LL(T: type)
#     next: &owned LL
#     data: T
    